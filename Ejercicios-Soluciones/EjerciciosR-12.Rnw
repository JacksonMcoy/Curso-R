\documentclass{article}
\usepackage[sc]{mathpazo}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{bigints}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\geometry{verbose,tmargin=1.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\usepackage{url}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\hypersetup{
 pdfstartview={XYZ null null 1}}
\begin{document}
<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
library(ggplot2)
library(grid)
# set global chunk options
opts_chunk$set(fig.path='figure/minimal-', fig.align='center', fig.show='hold')
options(formatR.arrow=TRUE,width=90)
@


\title{Ejercicios   de R}


\author{Curso: Introducci\'on a la Estad\'istica y Probabilidades CM-274}
\date{}
\maketitle

\vspace{0.3cm}


\textbf{Lecturas Importantes }
\begin{enumerate}
\item  Una introducci\'on visual al Machine Learning 

\url{http://www.r2d3.us/visual-intro-to-machine-learning-part-1/}.
\item  Art\'iculo de James Le 

\url{http://www.kdnuggets.com/2016/08/10-algorithms-machine-learning-engineers.html}  sobre \mbox{algunos} de los m\'as importantes  algoritmos del Machine Learning.
\end{enumerate}
%{\normalsize Los c\'odigos, se presentaran impresos,  o como un archivo con extensi\'on $.R$, mostrando ejemplos de su ejecuci\'on.}
\setlength{\unitlength}{1in}

\begin{picture}(6,.1) 
\put(0,0) {\line(1,0){6.25}}         
\end{picture}

\vspace{0.2cm}

{\Large Preguntas }


\vspace{0.3cm}

\begin{enumerate}

\item Se puede crear un \texttt{array} de prueba de $3$ dimensiones, de la siguiente manera

<<fo1, prompt =TRUE, comment =NA, eval=FALSE>>=
p_Array <- array( sample( 1:60, 60, replace=F), dim=c(5,4,3) )
@

La expresi\'on anterior produce un array $5 \times 4 \times 3$, que puede representado matem\'aticamente como

\[
\{ x_{i, j, k} : i = 1, 2, \dots, 5; j = 1, 2, 3,  4;  k = 1, 2, 3 \}
\]

Adem\'as   

<<fo2, prompt =TRUE, comment =NA, eval=FALSE>>=
apply(p_Array, 3, tmpFn)
@

significa que el \'indice $k$ es guardado en la respuesta y la funci\'on \texttt{tmpFn} es aplicado  a las $3$ matrices

$\{ x_{i, j, 1 }: 1 \leq  i \leq 5;   1 \leq j \leq 4\}$, $\{x_{i , j ,  2 }: 1 \leq i \leq 5;  1  \leq j \leq 4\}$ y $\{x_{i, j,3} : 1 \leq i \leq  5;  1 \leq j \leq 4\}$.


Similarmente 

<<fo3, prompt =TRUE, comment =NA, eval=FALSE>>=
apply(p_Array, c(3, 1), tmpFn)
@

significa que los \'indices $i$ y $k$ son guardados en las respuestas y la funci\'on \texttt{tmpFn} es aplicado  a los $15$ vectores


\vspace{0.2cm}

$\{ x_{i, j, 1 }:   1 \leq j \leq 4\}$,  $\{ x_{i, j, 2 }: 1 \leq j \leq 4\}$, etc.

\vspace{0.2cm}


La expresi\'on anterior, hace la misma operaci\'on, pero el formato de la respuesta es diferente: al usar \texttt{apply} de esta manera, siempre vale la pena escribir un peque\~no ejemplo para comprobar que el formato de la salida de \texttt{apply} es como se espera.

\begin{enumerate}
\item Escribe una funci\'on \texttt{p\_Fn} que toma un s\'olo argumento, que es una array de dimensi\'on $3$. Si este array es notado por $\{x_{i ,j, k}: i = 1, 2, \dots , d_1;  j = 1, 2, \dots, d_2; k = 1, 2, \dots, d_3 \}$ entonces a funci\'on \texttt{tmpFn} retorna una lista de la matriz $\{w_{i,j, k} \}$ de orden $d_1 \times d_2 \times d_3$ y la matriz $\{z_{i,j} \}$ de orden $d_2 \times d_3$, donde

\[
w_{i, j, k} = x_{i, j, k} - \min_{i = 1}^{d_1}x_{i, j, k}\ \ \ \text{y}\ \ \  z_{j, k} = \min_{i = 1}^{d_1}x_{i, j, k} - \max_{i = 1}^{d_1}x_{i, j, k}
\]

\item Escribe una funci\'on \texttt{p\_Fn2}, que retorna una matriz $\{z_{j ,k}\}$ de orden $d_2 \times d_3$, donde

\[
z_{j, k} = \sum_{i =1}^{d_1}x^k_{i, j, k}.
\]
\end{enumerate}
\item Un camino aleatorio sim\'etrico empieza en el origen y es definido como sigue: Supongase que $X_1, X_2, \dots $ son variables aleatorias id\'enticamente distribuidas independientes con la siguiente \mbox{distribuci\'on }

\[
\begin{cases}
+ 1 & \text{con probabilidad } \ \ 1/2 \\
- 1 & \text{con probabilidad }  \ \ 1/2
\end{cases}
\]

Definimos la secuencia $\{S_n\}_{n \geq 0}$ como

\begin{align*}
S_0 &= 0 \\
S_n &= S_{n -1} + X_n, \ \ \text{para } \ \ n = 1, 2, \dots
\end{align*}

Entonces $\{S_n\}_{n \geq 0}$ es un camino aleatorio sim\'etrico empezando en el origen. La posici\'on del camino aleatorio en el tiempo $n$ es la suma de los previos pasos : $S_n = X_1 + \cdots X_n$.

\begin{enumerate}
\item Escribe una funci\'on \texttt{rcamino(n)} que toma un argumento $n$ y retorna un vector el cu\'al es una realizaci\'on de $(S_0, S_1, \dots, S_n)$ las primeras $n$ posiciones de un camino aleatorio sim\'etrico que empieza en el origen. El c\'odigo siguiente 

<<fo4, prompt =TRUE, comment =NA, eval=FALSE>>=
sample( c(-1,1), n, replace=TRUE, prob=c(0.5,0.5) )
@

simula $n$ pasos.

\item Escribe una funci\'on \texttt{rcaminoPos(n)} que simula el hecho que un camino dura   para una longitud  de tiempo $n$ y que  devuelve la longitud de tiempo del camino que pasa por encima del eje X. Debes observar que un camino  con longitud $6$ y v\'ertices en  $0, 1, 0, -1, 0, 1, 0$ est\'a 4 unidades de tiempo por encima del eje X y 2 unidades de tiempo por debajo del eje X).

\end{enumerate}
\item El conjunto de datos \texttt{faithful} contiene la duraci\'on (en minutos )  \texttt{eruptions} y el tiempo de espera  hasta otra erupci\'on \texttt{waiting}(en minutos) de para un geyser Old Faithful. Estamos interesados en conocer la relaci\'on que hay entre las dos variables.

\begin{enumerate}
\item Crea una variable factor \texttt{longitud} que es \textbf{t\_erup1} si la erupci\'on es menor que $3.2$ minutos y \textbf{t\_erup2} en otros casos.

\item Usa la funci\'on \texttt{bwplot} en el paquete \texttt{lattice}, para construir un gr\'afico (diagrama de cajas paralelos ) de los tiempos de espera para las erupciones  \textbf{t\_erup1} y \textbf{t\_erup2}.
\item  Usa la funci\'on \texttt{densityplot}  construye  un gr\'afico (de densidades superpuestas ) de los tiempos de espera para las erupciones  \textbf{t\_erup1} y \textbf{t\_erup2}.

\vspace{0.2cm}

En el problema anterior, se compararon los tiempos de espera de los g\'eiseres Old Faithful para las erupciones \textbf{t\_erup1} y \textbf{t\_erup2} donde la  variable \texttt{longitud} en el data frame \texttt{faithful}  define la duraci\'on de la erupci\'on.

\item Supongamos un data frame \texttt{dframe} que contiene una variable num\'erica \texttt{num.var} y un factor \texttt{factor.var}. Despu\'es de que el paquete \texttt{ggplot2} se halla cargado, entonces, los comandos de R

<<fo5, prompt =TRUE, comment =NA, eval=FALSE>>=
ggplot(dframe, aes(x = num.var, color = factor.var))
+ geom_density()
@

construir\'an  estimaciones de densidades superpuestas  de la variable \texttt{num.var} para cada valor del factor \texttt{factor.var}. Utiliza estos comandos para construir estimaciones de densidades superpuestas de los tiempos de espera de los g\'eiseres con erupciones \textbf{t\_erup1} y \textbf{t\_erup2}.
\item Con  un data frame \texttt{dframe} que contiene una variable num\'erica \texttt{num.var} y un factor \texttt{factor.var}, la sintaxis de \texttt{ggplot2}

<<fo6, prompt =TRUE, comment =NA, eval=FALSE>>=
ggplot(dframe, aes(x = num.var, color = factor.var))
+ geom_boxplot()
@

construir\'a caja de bloques paralelos de la variable \texttt{num.var} para cada valor del factor \texttt{factor.var}. Utiliza estos comandos para construir cajas de bloques paralelos  de los tiempos de espera de los g\'eiseres con erupciones \textbf{t\_erup1} y \textbf{t\_erup2}.


\end{enumerate}

\vspace{0.2cm}


Sugerencia: Revisa el siguiente ejemplo

<<fo7, prompt =TRUE, comment =NA, eval=FALSE>>=
library(ggplot2)

#datos de muestra

dat <- data.frame(dens = c(rnorm(100), rnorm(100, 10, 5))
                   , lines = rep(c("a", "b"), each = 100))
#Plot.
ggplot(dat, aes(x = dens, fill = lines)) + geom_density(alpha = 0.5)
@



\item Supongamos que se est\'a interesado en mostrar  $3$ miembros de la familia de curvas beta, donde la densidad con par\'ametros $a$ y $b$, denotados por \texttt{Beta(a, b)} es dado por

\[
f(y) = \frac{1}{B(a, b)}y^{ a - 1}(1 - y)^{b - 1}, \ \ 0 < y < 1.
\]

Se puede dibujar un sola densidad beta, con param\'etros $a = 5$ y $b = 2$, usando la funci\'on \texttt{curve}:

<<fo8, prompt =TRUE, comment =NA, eval=FALSE>>=
curve(dbeta(x, 5, 2), from=0, to=1)
@
\begin{enumerate}
\item Usa tres aplicaciones de la funci\'on \texttt{ curve} para mostrar las densidades   \texttt{Beta(2, 6)},  \texttt{Beta(4, 4)}  y  \texttt{Beta(6, 2)}  en un s\'olo gr\'afico.
\item Usa el siguiente comando de R, para colocar un t\'itulo  al gr\'afico de las ecuaciones de densidad beta


<<fo9, prompt =TRUE, comment =NA, eval=FALSE>>=
title(expression(f(y)==frac(1,B(a,b))*y^{a-1}*(1-y)^{b-1}))
@
\item Usa la funci\'on \texttt{text}, para etiquetar cada una de las curvas betas con sus correspondientes valores de los param\'etros $a$ y $b$.
\item Redibuja el gr\'afico usando diferentes colores o tipos de l\'ineas para las tres curvas de densidad.
\end{enumerate}
\item Explica el siguiente c\'odigo y el Teorema del L\'imite Centrak. La respuesta debe ser correctamente escrita y ordenada

<<fo10, prompt =TRUE, comment =NA, eval=FALSE>>=
iter = 2000
avg0 <- avg1 <- avg2 <- avg3 <- rep(0, iter)
for (i in 1:iter) {
    S = rexp(90)  # muestra desde la distribucion   exp(1) 
    avg0[i] = S[1]
    avg1[i] = mean(S[1:3])
    avg2[i] = mean(S[1:30])
    avg3[i] = mean(S[1:90])
}
SR = stack(list(`n=1` = avg0, `n=3` = avg1, `n=30` = avg2,
    `n=90` = avg3))
names(SR) = c("promedios", "n")
ggplot(SR, aes(x = averages, y = ..density..)) + facet_grid(n ~
    .) + geom_histogram() + scale_x_continuous(limits = c(0,
    3))
@
\item Escribe una funci\'on llamada \texttt{listaFN} que toma un \'unico argumento $n$ e implementa el siguiente algoritmo

\begin{enumerate}
\item Simula $n$ n\'umeros independientes, denotado por $\textbf{x} = (x_1, x_2, \dots, x_n)$ desde la distribuci\'on normal est\'andar.
\item Calcula la media $\overline{\textbf{x}} = \sum_{j =1}^{n}x_j /n$.
\item Si $\overline{\textbf{x}} \geq 0 $, entonces simula $n$ n\'umeros independientes, denotados por $\textbf{y} = (y_1, y_2, \dots, y_n)$ desde la densidad exponencial con media $\overline{\textbf{x}}$.
\item Si $\overline{\textbf{x}} < 0 $, entonces simula $n$ n\'umeros independientes, denotados por $\textbf{z} = (z_1, z_2, \dots, z_n)$ desde la densidad exponencial con media $-\overline{\textbf{x}}$. Se coloca  $\textbf{y} = (y_1, y_2, \dots, y_n) = \textbf{-z}$.
\item Calcula $k$ que es el n\'umero $j$ con $\vert y_j \vert > \vert x_j\vert$.
\item Retorna la lista de $\textbf{x, y}$ y $k$ con nombres \texttt{xVec, yVec} y \texttt{count} respectivamente.
\item Ejecuta las siguientes l\'ineas y verifica el formato de las respuestas


<<fo11, prompt =TRUE, comment =NA, eval=FALSE>>=
lapply( rep(10,4), listaFN )
sapply( rep(10,4), listaFN )
@
\end{enumerate}
\end{enumerate}
\end{document}
