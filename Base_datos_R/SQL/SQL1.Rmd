---
title: 'R y Bases de datos '
output:
  html_notebook: 
    highlight: zenburn
    theme: flatly
  html_document: default
---
#### Referencias: 

*  Data Manipulation with R, Phil Spector, Springer 2008.

* [A primer on SQL de Rahul Batra](https://leanpub.com/aprimeronsql/read).

* [Databases](https://cran.r-project.org/web/packages/dplyr/vignettes/databases.html).



###  Notas de SQL 

Un servidor puede almacenar más de una base de datos, cada una de ellas con muchas tablas y desde que cada 
tabla contiene muchas columnas(variables) es importante tener en cuenta  la disponibilidad total  de las  bases de datos disponibles. La siguiente tabla muestra esas tareas comunes y las declaraciones de **SQL** para ejecutarlas

```{sql}
SHOW DATABASES
SHOW TABLES IN basedatos
SHOW COLUMNS IN tabla
DESCRIBE tabla
USE basedatos 

```

Cuando usamos *clientes en modo comando * las declaraciones de SQL, debén de terminar en un punto y coma, pero esta coma no es requerida si es que usamos la interfaz de [RMySQL](https://cran.r-project.org/web/packages/RMySQL/index.html). 

En R, existen otros tipos de interfaces para otras sistemas de bases de datos como [RPostgreSQL](https://cran.r-project.org/web/packages/RPostgreSQL/).

El primer paso para SQL, es que no es un lenguaje de programación, a diferencia de R; las operaciones en SQL son llevadas a cabo usando peticiones individuales sin bucles o declaraciones de control. El comando más importante de SQL es `SELECT`, cuya uso a partir de que las peticiones usan una única petición, puede tener un aspecto parecido a 

```{sql}
SELECT columnas
  FROM tabla
  WHERE condicion
  GROUP BY columnas
  HAVING condicion
  ORDER BY columnas [ASC|DESC]
  LIMIT numero 
```

Muchas de las declaraciones de peticiones que se declaran en `SELECT` son opcionales. Por ejemplo algunas peticiones pueden recuperar todos los datos  en una tabla en particular, donde el símbolo `*` significa *todas las columnas de la tabla* usando el siguiente comando

```{sql}
SELECT * FROM tabla_particular;
```
Una lista de variables, separadas por comas, puede ser  proporcionada por la siguiente expresión


```{sql}
SELECT var1, var2, var3/var2 from tabla_particular;
```
 Un comando útil y opcional es `AS`, el cual puede ser usado para cambiar el nombre de una columna en el resultado de un conjunto
 
 
 ```{sql}
 SELECT var1, var2, var3/var2 AS radio from tabla_particular;
 ``` 
 
 La cláusula `WHERE` junto con  `AND` y `OR` pueden ser usada para limitar las filas que son devueltas en una petición

```{sql}
SELECT * FROM tabla_particular WHERE  var1 > 10 AND var2 < var 1;
```
 Una importante limitación de `WHERE` es que no puede acceder a las variables que fueron creadas en la declaración `SELECT`, en ese caso se debe usar la  cláusula `HAVING`. Asi para encontrar los casos donde el radio es mayor que 10, se hace los siguiente


```{sql}
SELECT var1, var2, var2/var1 AS radio
  FROM tabla_particular HAVING radio > 10;
```

Dos operadores en SQL, son útiles para variables de tipo caracter. El operador `LIKE` permite el uso de `%` para representar cero o más de un caracter y `_` para representar un sólo caracter. El operador `RLIKE` permite el uso de expresiones regulares para caracteres de comparación.

### Agrupación

 La cláusula `GROUP BY`junto con algunas funciones  de agrupación proporcionados por SQL, pueden ser útiles si se desea producir tablas de cuentas o resumen de datos de una base de datos, sin tener que conseguir toda la base de datos en si. Algunas funciones de agrupación para SQL son
 
 ```
 COUNT()
 AVG()
 MIN()
 MAX()
 VAR_SAMP()
 STDDEV_SAMP()
 LAST()
 FIRST()
 SUM()
 ```

Por ejemplo, si queremos crear una tabla de la medias  para una variable `x` desde una tabla de base de datos llamada `tabla1`, dividida por una variable catégorica llamada `tipo`, podemos construir una tabla con los valores `tipo1` y `media` como sigue 

```{sql}
SELECT tipo1, AVG(x) AS media FROM tabla1 GROUP BY tipo1;
```
 
Se debe recordar incluir la variable de agrupación en la lista de variables seleccionadas, ya que SQL no  hará esto  automáticamente. Desde que  `media` es una variable calculada en este ejemplo, se tendría que utilizar una cláusula `HAVING` para limitar los datos  que fueron devueltos en base al valor de  `media`.


Como el número de datos de alguna columna en una tabla en particular es el mismo, es una práctica común usar un asterisco (*) como un argumento para la función `COUNT`. Para crear una tabla de recuentos por `tipo1` en el previo ejemplo, podríamos haber usado 

```{sql}
SELECT tipo1, COUNT(*) FROM tabla1 GROUP BY tipo1;
```

Para agrupar más de una variable, usamos una lista separada por comas como un argumento de la cláusula `GROUP BY`. Múltiples funciones de agrupamiento estadístico pueden ser devueltas fácilmente con una única petición. Por ejemplo

```{sql}
SELECT tipo1 ,COUNT(*),AVG(x) AS media,STDDEV_SAMP(x) AS std
  FROM tabla1 GROUP BY tipo1;
```

### Uniendo  dos  bases de datos

Uno de los puntos fuertes de los servidores de bases de datos es que pueden unir de manera efectiva varias tablas de bases de datos, basados en los valores comunes de las columnas de las tablas. Por supuesto, la misma capacidad está disponible dentro de R a través de la función `merge`, pero se puede ser  más eficiente  utilizar el servidor de base de datos para la unión.

La forma más común de unir dos tablas es a través de una unión interna; sólo aquellos datos que tienen valores comunes de la variable utilizada para la unión  serán retenidos en la tabla de salida. (Este es también el comportamiento por defecto de la función de `merge`).


Por ejemplo supongamos que tenemos una tabla llamada  `comunidadpython`, con las columnas `id` `id_comunidad`, `usuario`, `desarrollador`, y  una segunda tabla llamada `comunidadR` con columnas `id`, `id_comunidad` y `tester` . Si queremos una tabla con las columnas `usuario` , `desarrollador` de `comunidadpython ` y la columna `tester` de `comunidadR`, SQL puede hacer esto con las siguientes intrucciones

```{sql}

SELECT usuario, desarrollador, tester FROM comunidadpython
  INNER JOIN comunidadR USING(id_comunidad);
```

La variable en la expresión `USING` (en ejemplo, `id_comunidad`) es conocida como *llave foránea*. Si dos tablas son unidas con una única llave foránea, entonces `INNER JOIN`, se convierte en `NATURAL JOIN` y la expresión `USING` puede ser omitida.  


Si queremos tener una tabla con los *id* de `comunidadpython` y `comunidadR`. Como las variables son llamadas en ambos casos `id`, debemos distinguir entre ellas, precediendo el nombre de la columna con el nombre de la tabla y un punto.

```{sql}
SELECT comunidadpython.id, comunidadR.id, usuario, desarrollador, tester
  FROM comunidadpython INNER JOIN comunidadR USING(id_comunidad ) ;
```

El operador `AS` se puede utilizar para referenciar varias tablas, además de renombrar columnas

```{sql}
SELECT p.id as pid,r.id as rid,usuario,desarrollador,tester
  FROM comunidadpython AS p
  INNER JOIN comunidadR AS r USING(id_comunidad );
```
### Subconsultas


###  Modificación de los registros de base de datos

Para cambiar los valores de los registros seleccionados en una base de datos, el comando `UPDATE` se puede utilizar. El formato de la instrucción UPDATE es

```{sql}
UPDATE tabla SET var = valor
  WHERE condicion
  LIMIT n;
```

Para cambiar el valor de más de una variable, la especificación `var = valor`  debe  ser sustituida por una lista separada por comas de pares de *variables-valor*. Las especificaciones `WHERE` y `LIMIT` son opcionales.

Si se proporciona una especificación `LIMIT`, sólo se tendrán en cuenta esos registros para la actualización, incluso si algunos de los registros seleccionados en realidad no se pueden modificar. Por ejemplo, para cambiar la información de `usuario` y `desarrollador` de la comunidad python  con un identificador en particular, podríamos usar una declaración, de la siguiente forma

```{sql}
UPDATE comunidadpython  SET usuario=100,desarrollador=55
  WHERE id = 12345;
```
Para eliminar completamente un registro, la instrucción `DELETE` se puede utilizar. La sintaxis básica es la siguiente:

```{sql}
DELETE FROM tabla
  WHERE condicion
  LIMIT n;
```

Sin una cláusula `WHERE`, todos los registros de la tabla de base de datos se eliminará, por lo que esta declaración se debe utilizar con precaución. Si se proporciona una especificación `LIMIT`, se basa en observaciones que cumplen la condición de la cláusula `WHERE`, si se especifica una.


Finalmente, para remover completamente una tabla entera o una base de datos, la  cláusula `DROP` puede ser usada

```{sql}
DROP TABLE nombre_tabla

```

o 

```{sql}
DROP DATABASE db_nombre
```


Cuando se utiliza la cláusula `DROP`, se informará de un error si la tabla o base de datos que se remueve, no existe. Para evitar esto, la cláusula `IF EXISTS` se pueden añadir a la instrucción `DROP`, como en

```{sql}
DROP DATABASE IF EXISTS db_nombre
```

### ODBC

El desarrollo de bases de datos , permite abstraer toda la gestión de datos a sistemas especializados. Como hay muchas DBMS (sistema de gestión de datos), se desarrollo una definición para una conexión genérica llamada **ODBC**. Esto es una sigla para *Open Database Connectivity*, el cual actúa como una interfaz entre la base de datos y el lenguaje de programación que lo utiliza

Es por eso que RODBC se puede usar para conectar con muchos tipos de base de datos. PostgreSQL MySQL, Microsft SQL Server, IBM DB2, SQLite para nombrar los mas comunes.

Una típica conexión con RODBC podría tener la siguiente forma:

```{r}
library(RODBC)
canal_bd <- odbcDriverConnect('driver={SQL Server};
                                  server=mi_maquina;
                                  database=mi_base_de_datos;
                                  trusted_connection=true')
resultado <- sqlQuery(canal_bd, 'SELECT * FROM mi_bd')  
odbcClose(canal_bd)
```

En palabras: abrimos un canal hacía la base de datos que llamamos *canal_db*. Esto ahora es un objeto que contiene toda la información para hacer una conexión usando ODBC, incluyendo el tipo de conexión (cual base de datos), la dirección de la maquina donde esta la base de datos (puede ser localhost cuando es el mismo computador donde estamos trabajando), y el nombre de la base de datos.

A nivel de tablas trabajamos al hacer búsquedas, como y entre varias formas que permite RODBC, podemos definir la búsqueda definiendo el canal (en nuestro caso canal_bd) y el código en SQL.


### DBI

DBI (Database Interface) es una nueva forma para conectar R con bases de datos. Es una propuesta que debía dar una respuesta nativa a R para  tener una funcionalidad similar a otros conectores, como el ODBC (de Microsoft), JDBC (de Oracle), el DBI de Perl y el DB-API de Python. 

Por ejemplo, para hacer una conexión con SQLite se formularia la siguiente instrucción:


```{r}
library(DBI)
conexion <- dbConnect(RSQLite::SQLite(), dbname = "mi_bd")
resultado <- dbSendQuery(con, "SELECT * FROM mi_bd")
```
Esto requiere que el controlador esté instalado por aparte  `(install.packages("RSQLite"))`. Son pocos los casos donde es preferible usar  `RODBC` sobre el paquete basado en `R-DBI`.