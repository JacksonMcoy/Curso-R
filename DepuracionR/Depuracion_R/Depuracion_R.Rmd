---
title: "Depuración con R"
output: 
  html_notebook: 
    highlight: pygments
    theme: united
---

#### Referencias 

*  Software Development and Professional Practice, John Dooley, Apress 2011.
* [Depuración con R](https://www.wisdomandwonder.com/link/8903/debugging-in-r).

Como en cualquier programa, R ocasionalmente produce errores que no son faciles de entender. Un forma de depurar es insertar declaraciones de `print` en algunas localizaciones, el cual consume tiempo e ineficiencia. 

R proporciona un número de herramientas de depuración:

* `traceback()`
* `debug()`
* `browser()`
* `trace()`
* `recover()`

Una herramienta que alguna veces es útil es la función `traceback()`. Si un programa falla, y no está claro donde o porqué, invocar  `traceback()`, puede proporcionar información útil.

```{r}
f<-function(x) {
   r<-x-g(x)
   r
}

g<-function(y) {
  r<-y*h(y)
  r
}

h<-function(z) {
  r<-log(z)
  if(r<10)
    r^2
  else
    r^3
}
f(-1)
```

```{r}
traceback()
```
La función `traceback()` imprime todas las funciones que fueron llamadas antes de que el error ocurra. Las funciones son impresas en un orden inverso. `traceback()` no nos dice donde en la función se produjo el error. Con el fin de saber qué línea provoca el error, es posible utilizar la función `debug()`.


* `debug(f1)` marca la función `f1()` para depurar.
* `undebug(f1` desmarca la función.
* Cuando una función se encuentra en posición de depuración, cada sentencia en la función se ejecuta una a la vez. Después que se ejecuta una sentencia, la función se suspende y se puede interactuar con el entorno.

* Después de obtener la información necesaria del entorno, podemos dejar  que la función  ejecute la siguiente sentencia. De esta manera, se puede comprobar la  función línea por línea. 

```{r}
# suma de cuadrados
SC<-function(mu,x) {
  d<-x-mu
  d2<-d^2
  ss<-sum(d2)
  ss
}
```

Ejecutamos la función 


```{r}
set.seed(100)
x<-rnorm(100)
SC(1,x)
```



 Después de ver el prompt `Browse[1]` en la depuración, se pueden hacer diferentes cosas:
 
-  Escribiendo **n** se  ejecuta la línea actual e imprime la siguiente;
-  Tipeando  **c** se  ejecuta el resto de la función sin parar;
-  Pulsar **Q** se cierra la depuración;
- Tecleando **ls()** lista de todos los objetos del entorno local;
- Al escribir un nombre de objeto o escribir `print(<nombre de objeto>)` se tiene el valor actual del objeto. Si el objeto tiene nombre de `n, c` o `Q`, se puede  utilizar `print()` para ver sus valores.


```{r}
debug(SC)
SC(1,x)
```
Que se reproduce como en la consola de R, como 
```
Browse[2]> n
debug en #2: d <- x - mu
Browse[2]> n
debug en #3: d2 <- d^2
Browse[2]> n
debug en #4: ss <- sum(d2)
Browse[2]> n
debug en #5: ss
Browse[2]> n
exiting from: SC(1, x)
[1] 202.5615
```

Por ejemplo si usamos en la consola, para depurar 

```

Browse[2]> n
debug en #2: d <- x - mu
Browse[2]> ls()
[1] "mu" "x" 
Browse[2]> n
debug en #3: d2 <- d^2
Browse[2]> ls()
[1] "d"  "mu" "x" 
Browse[2]> d[1:3]
[1] -1.5021924 -0.8684688 -1.0789171
Browse[2]> hist(d)
Browse[2]> where
where 1: SC(1, x)

Browse[2]> n
debug en #4: ss <- sum(d2)
Browse[2]> Q
```
 en el código inicial, se obtiene
```{r}
debug(SC)
SC(1,x)
```

