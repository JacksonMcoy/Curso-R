---
title: "Listas y data frames "
output: 
  html_notebook: 
    highlight: kate
    theme: spacelab
---

## Lista 

A diferencia de un vector, en el que todos los elementos deben ser del mismo tipo, la estructura de  una lista en R puede combinar objetos de diferentes tipos. Una lista  en R es similar a un diccionario de Python o, a un hash de Perl o puede resultar similar a una estructura de  C. Las listas son muy importantes en R, formando la base para los data frames,la  programación orientada a objetos,etc.

Se puede construir listas usando ` list()`.

```{r}
x <- list(1:3, "a", c(TRUE, FALSE, TRUE), c(2.3, 5.9))
str(x)
```

```{r}
(a_lista <- list(
c(1, 1, 2, 5, 14, 42), #See http://oeis.org/A000108
month.abb,
matrix(c(3, -8, 1, -3), nrow = 2),
asin
))
```

Al igual que con los vectores, podemos  nombrar elementos durante la construcción, o después usar la función `names()`

```{r}
names(a_lista) <- c("catalan", "months", "involutary", "arcsin")
a_lista
```

```{r}
(otra_lista <- list(
  catalan = c(1, 1, 2, 5, 14, 42),
  months = month.abb,
  involutary = matrix(c(3, -8, 1, -3), nrow = 2),
  arcsin = asin
))
```

No es obligatorio, pero ayuda si los nombres que le damos a los  elementos son variables válidas. Incluso es posible que los elementos de las listas sean listas

```{r}
(lista_inicial <- list(
  lista_media = list(
    elemento_en_media_lista = diag(3),
    interior_lista = list(
      elemento_en_interior_lista = pi ^ 1:4,
      otro_elemento_en_interior_lista = "a"
      )
    ),
elemento_en_lista_inicial = log10(1:10)
))
```

Debido a esta capacidad de contener otras listas dentro de sí, las listas se consideran variables recursivas. Los vectores, matrices y array, por el contrario, son atómicos. (Las variables pueden ser recursivas o atómicas, nunca las dos) Las funciones `is.recursive` y `is.atomic`  permiten probar variables para ver de qué tipo son

```{r}
is.atomic(list())
is.recursive(list())
is.atomic(numeric())
is.recursive(numeric())
```

Como vectores, las listas tienen una longitud. La longitud de una lista es el número de elementos  que contiene. 

```{r}
length(a_lista)
```

```{r}
length(lista_inicial)
```



De nuevo, como los vectores, pero a diferencia de las matrices, las listas no tienen dimensiones. La función `dim` devuelve correspondientemente `NULL`. ``nrow`, `NROW`  y las funciones de columna correspondientes funcionan en listas de la misma manera que en vectores

```{r}
dim(a_lista)
```

```{r}
nrow(a_lista)
```

```{r}
ncol(a_lista)
```

```{r}
NROW(a_lista)
```

```{r}
NCOL(a_lista)
```

A diferencia de los vectores, la aritmética no funciona en las listas, ya que  cada elemento puede ser de un tipo diferente, por lo que no tiene sentido poder agregar o multiplicar dos listas. Es posible hacer aritmética en elementos de lista, sin embargo, suponiendo que son de un tipo apropiado. En ese caso, se aplican las reglas habituales para los elementos.

```{r}
l1 <- list(1:5)
l2 <- list(6:10)
l1[[1]] + l2[[1]]
```

Se puede acceder a una lista de diversas maneras, por ejemplo si se quiere acceder a un elemento `c` de una lista  llamada `lista`

```
 lista$c
 lista[["c"]]
 lista[[i]], donde i es el índice de c dentro de lista.
```
Una alternativa de listar elementos de una lista es usar un solo corchete en lugar de dos

```
lista["c"]
lista[i],  donde i es el índice de c dentro de lista.
```

Si un único corchete es usado `[]` el resultado es otra lista, una sublista de la original.

```{r}
lenguaje <- list(name1="Python", name2=5, name3="Interpretado")
lenguaje
lenguaje$name1
lenguaje[["name2"]]
lenguaje[[3]]
```

```{r}
# Usando un solo corchete

lenguaje[1:2]
lenguajes1<-lenguaje[3]
lenguajes1
class(lenguajes1)
str(lenguajes1)
```

Usando doble corchetes `[[ ]]` se refieres a una sola componente, con el resultado de tener el tipo de esa componente

```{r}
lenguaje[[1:1]]
lenguajes2 <-  lenguaje[[3]]
lenguajes2
class(lenguajes2)
```

Hay otros dos operadores para extraer elementos de una lista: `[[` y `$`. `[[` es similar a `[`, excepto que sólo puede devolver un solo valor. `$` es un atajo útil para `[[` combinado con  de carácteres.

Es necesario el uso de `[[` cuando se trabaja con listas. Esto es porque cuando `[` se aplica a una lista  siempre devuelve una lista: nunca devuelve el  contenido de la lista. Para obtener el contenido, es necesario `[[` 


```{r}
ar <- list(a = 1, b = 2)
ar[[1]]
ar[["a"]]
```

```{r}
b2 <- list(a = list(b = list(c = list(d = 1))))
b2[[c("a", "b", "c", "d")]]

# O lo que es lo mismo

b2[["a"]][["b"]][["c"]][["d"]]
```

```{r}
# uso de [] en lista, produce otras sublistas

l <- list(
  first = 1,
  second = 2,
  third = list(
    alpha = 3.1,
    beta = 3.2
    )
  )

l[1:2]
l[-3]
l[c("first", "second")]
l[c(TRUE, TRUE, FALSE)]
```
```{r}
# uso de [[]] para acceder al contenido de un solo elemento

l[[1]]
l[["second"]]
```

La función `is.list` devuelve `TRUE` si la entrada es una lista, y `FALSE` en caso contrario. Para una comparación, eche un vistazo a los dos operadores de indexación

```{r}
is.list(l[1])
```

```{r}
is.list(l[[1]])
```

Para los elementos con nombre de las listas, también podemos utilizar el operador  `$`. Esto funciona casi de la misma manera que pasar una cadena con nombre a los corchetes dobles.

```{r}
l$second
```

```{r}
l$f
```

Para acceder a los elementos anidados, podemos apilar los corchetes o pasar en un vector, aunque el último método es menos común y por lo general más difícil de leer

```{r}
l[["third"]]["beta"]
```

```{r}
l[["third"]][["beta"]]
```

```{r}
l[[c("third", "beta")]]
```

El comportamiento cuando se intenta  acceder  a un elemento inexistente de una lista varía dependiendo del tipo de indexado. Para el siguiente ejemplo, las lista  `l`  tiene sólo tres elementos.

Si utilizamos la indexación con `[ ]`, la lista resultante tiene un elemento con el valor `NULL` (y `NA` si la lista original tiene nombres). Comparamos esto con la mala indexación de un vector donde el valor de retorno es `NA`.

```{r}
l[c(4, 2, 5)]
```

```{r}
l[c("fourth", "second", "fifth")]
```
Intentar acceder al contenido de un elemento con un nombre incorrecto, ya sea con doble corchetes o un signo de dólar, devuelve `NULL`


```{r}
l[["fourth"]]
l$fourth
```

Finalmente, intentar acceder al contenido de un elemento con un índice numérico incorrecto arroja un error, indicando que el subíndice está fuera de límites. Esta inconsistencia en el comportamiento es algo que sólo necesita aceptar, aunque la mejor defensa es asegurarse de que compruebe sus índices antes de usarlos

```{r}
l[[4]]
```

Una aplicación natural de todo esto es la de agregar  y eliminar  elementos de una lista


```{r}
l <-list(a = "python", b= c(1,2,4), c = 13)
l
l$d <- "Milagros"  # agrego un componente
l
l[[5]]<- 20
l [6:8]<- c(TRUE, TRUE, FALSE)
l

```
```{r}
# Podemos eliminar componentes poniendo NULL a la componente

l$b <-NULL
l
```
Podemos acceder a los componentes de una lista

```{r}
lenguaje <- list(name1="Python", name2=5, name3="Interpretado")
names(lenguaje)
help(unlist)
leng <- unlist(lenguaje)
leng
class(leng)
```

Por otro lado  si tuviéramos que empezar con  números, obtendríamos números.

```{r}
ll <- list(a=2,b=3,c=4)
ll1 <-unlist(ll)
class(ll1)
ll1
```

```{r}
# En un caso de elementos distintos 
x
x1 <-unlist(x)
class(x1)
x1
```


Los vectores se pueden convertir en listas utilizando la función `as.list`.

```{r}
b_b <- c(1, 6, 21, 107) #See http://oeis.org/A060843
as.list(b_b)
```


Si cada elemento de la lista contiene un valor escalar, también es posible convertir esa lista en un vector utilizando las funciones `is.numérico`, `as.caracter`, etc.

```{r}
as.numeric(list(1, 6, 21, 107))
```

Esta técnica no funcionará en los casos en que la lista contenga elementos no escalares. Este es un problema real, ya que además de almacenar diferentes tipos de datos, las listas son muy útiles para almacenar datos del mismo tipo, pero con una forma no rectangular

```{r}
(factores_primos <- list(
  dos = 2,
  tres = 3,
  cuatro = c(2, 2),
  cinco = 5,
  seis = c(2, 3),
  siete = 7,
  ocho = c(2, 2, 2),
  nueve = c(3, 3),
  diez = c(2, 5)
))
```
Este tipo de lista se puede convertir en un vector utilizando la función `unlist`  (a veces es técnicamente posible hacer esto con listas mixtas, pero rara vez es útil)

```{r}
vecl<-unlist(factores_primos)
vecl
class(vecl)
```

La función `c` que hemos utilizado para concatenar vectores también funciona para concatenar listas

```{r}
c(list("Jessica", 55000, T),list(51))
```

```{r}
c(list(a = 1, b = 2), list(3))
```

Si lo usamos para concatenar listas y vectores, los vectores se convierten en listas (como si se hubiera llamado `a.list`) antes de que ocurra la concatenación

```{r}
c(list(a = 1, b = 2), 3)
```

También es posible utilizar las funciones `cbind` y `rbind` en las listas, pero los objetos resultantes son realmente muy extraños. Son matrices con elementos posiblemente no escalares, o listas con dimensiones, dependiendo de la forma en que desees verlas

```{r}
(matriz_lista <- cbind(
  list(a = 1, b = 2),
  list(c = 3, list(d = 4))
))
str(matriz_lista)
```

`NULL` es un valor especial que representa una variable vacía. Su uso más común es en listas, pero también surge con datos frames  y argumentos de función.

Al crear una lista, es posible que desee especificar que un elemento debe existir, pero no debe tener contenido. Por ejemplo, la siguiente lista contiene los días festivos en el Reino Unido  para 2013 por mes. Algunos meses no tienen días festivos, por lo que utilizamos `NULL` para representar esta ausencia


```{r}
(uk_bank_holidays_2013 <- list(
  Jan = "New Year's Day",
  Feb = NULL,
  Mar = "Good Friday",
  Apr = "Easter Monday",
  May = c("Early May Bank Holiday", "Spring Bank Holiday"),
  Jun = NULL,
  Jul = NULL,
  Aug = "Summer Bank Holiday",
  Sep = NULL,
  Oct = NULL,
  Nov = NULL,
  Dec = c("Christmas Day", "Boxing Day")
))
```
Es importante entender la diferencia entre `NULL` y el valor especial  `NA`. La mayor diferencia es que `NA` es un valor escalar, mientras que NULL no ocupa espacio alguno: tiene una longitud cero.

```{r}
length(NULL)
```

```{r}
length(NA)
```

`NULL` también se puede utilizar para eliminar elementos de una lista. Establecer un elemento en  `NULL` (incluso si ya contiene `NULL`) lo eliminará. Supongamos que por alguna razón queremos cambiar a un calendario romano de 10 meses de estilo antiguo, eliminando enero y febrero:


```{r}
uk_bank_holidays_2013$Jan <- NULL
uk_bank_holidays_2013$Feb <- NULL
uk_bank_holidays_2013
```
Para establecer un elemento existente como `NULL`, no podemos simplemente asignar el valor de `NULL``  ya que eliminará el elemento. En su lugar, debe establecerse en `list(NULL)`. Ahora supongamos que el gobierno del Reino Unido se convierte en mediocre y cancela las vacaciones de verano:

```{r}
uk_bank_holidays_2013["Aug"] <- list(NULL)
uk_bank_holidays_2013
```

R tiene otro tipo de lista, el `pairlist`que  se utilizan internamente para pasar los argumentos a las funciones, pero casi nunca tendrás que usarlas activamente. Posiblemente la única vez que se les vea es cuando se utilizan en `formals`. Esta función devuelve un `pairlist` de los argumentos de una función.

Observando la página de ayuda para la función de desviación estándar `? sd`, vemos que se necesitan dos argumentos, un vector `x` y un valor lógico `na.rm`, que tiene un valor por defecto de `FALSE`:

```{r}
(argumentos_de_sd <- formals(sd))
```

Para fines más prácticos, un `pairlist` se comporta como una lista. La única diferencia es que un `pairlist`  de longitud cero es `NULL`, pero una lista de longitud cero es sólo una lista vacía:

```{r}
pairlist()
```
```{r}
list()
```



Dos funciones son muy útiles para la aplicación de  listas son `lapply()` y `sapply()`.  Más información sobre la familia `apply()` en [stackoverflow:r-grouping function ](http://stackoverflow.com/questions/3505701/r-grouping-functions-sapply-vs-lapply-vs-apply-vs-tapply-vs-by-vs-aggrega). 

```
lapply (list, f, fargs...)}
```

- `list` es una lista
- `f`  es la función ha ser aplicada por ``lapply`
- `fargs` son otros   paramétros

La función `lapply()` aplica una función a los elementos de una lista o vector y devuelve los resultados en una lista. La función `lapply()`  es útil cuando se trata con  data frames. En R, los `data frames`  se consideran una lista y las variables  son los elementos de la lista, así podemos aplicar una función a todas las variables en un data frame  usando `lapply()`.

`sapply()` aplica una función a los elementos de una lista y devuelve los resultados en un vector, matriz o una lista. 

```
sapply(lista, f,...simplify)}
```

- `list` es una lista
- `f`  es la función ha ser aplicada por `sapply`
- `simplify` --> Cuando el argumento `simplify = F` entonces la función  `sapply()` devuelve los resultados en una lista como la función  `lapply()`.  Cuando  `simplify = T`, `sapply()` devuelve los resultados en una forma simplificada. Si los resultados son todos  escalares entonces `sapply()` devuelve un vector. Si los resultados son todos de la misma longitud `sapply()` entonces devolverá una matriz con una columna para cada elemento en la lista a la que se aplicó la función.

```{r}
help(lapply)
lapply(list(1:5, 25:29), median)
unlist(lapply(1:5, function(i) print(i) ))
```

```{r}
tiempo <-c(1,2,3,4,5,6,7)
demanda <-c(8.3, 10.4, 19.0, 17.0, 15.8, 15.3, 19.8)
BID =data.frame(tiempo, demanda)
dl <-lapply(BID, sort)
dl
as.data.frame(dl)
```

```{r}
sapply(list(1:3, 25:29), median)
z <- function(z) return (c(z, z^2))
sapply(1:8, z)
```

```{r}
 # Un ejemplo más complejo

str(InsectSprays)
str(split(InsectSprays$count, InsectSprays$spray)  )
sapply(  split(InsectSprays$count, InsectSprays$spray),  mean  )
```


Todos los objetos pueden tener atributos adicionales arbitrarios, que se utilizan para almacenar metadatos sobre el objeto. Los atributos pueden ser considerados como una lista con nombre (con nombres únicos). Los atributos se pueden acceder individualmente con `attr()` o todos a la vez (como una lista) con los `attributes()`.

```{r}
y <- 1:9
attr(y, "un_atributo") <- "Es un vector"
attr(y, "un_atributo")
str(attributes(y))

m <- "Jessica"
attr(m, "un atributo") <- "Ella es bella"
attr(m, "un atributo")
str(attributes(m))
```

La función `structure()` retorna un nuevo objeto, con atributos modificados:

```{r}
help(structure)
structure(1:10, my_attribute = "Esto es un vector")
```

Por defecto muchos atributos están pérdidos cuando modificamos el  vector:

```{r}
attributes(y[1])
attributes(sum(y))
```

Los únicos atributos no perdidos son los tres más importantes:

- `Names`, un vector de caracteres dando a cada elemento  un nombre.
- `Dimension`, utilizado para convertir vectores en matrices y arrays.
- `Class`, usado para implementar el sistema S3.

Cada uno de estos atributos tiene una función específica de acceso para obtener y establecer los valores. Al trabajar con estos atributos, se usan  `names(x)`, `dim(x)`, y  `class(x)`, no `attr (x, "name")`, `attr (x, "dim")`, y `attr (x, "class")`.

## Data frames

Un data frame  es la forma más común de almacenamiento de datos en R, y si se utiliza sistemáticamente en  el análisis de datos como se explica el artículo [datos ordenadados de Hadley Wickman](http://vita.had.co.nz/papers/tidy-data.pdf).

Los data frame  son  una lista de vectores de la misma longitud,  que hace que sea una estructura de dos dimensiones,  que comparte propiedades tanto de las matrices y  de las listas. Esto significa que un data frames  tenga las funciones `names()`, `colnames()` y `rownames()`. La `length()` de una data frame  es la longitud de la lista subyacente y así es el mismo valor  que produce `ncol()`.  `nrow()` da el número de filas.

Se puede tener parte   de un data frame como una estructura de una dimensión (que se comporta como una lista), o una estructura de dos dimensiones (que se comporta como una matriz).


Se puede crear un data frame usando la función `data.frame()` de la siguiente manera


```{r}
help(data.frame)
df <- data.frame(x = 1:3, y = c("Python", "R", "C"))
str(df)
```


El  comportamiento predeterminado de `data.frame()`  convierte cadenas en factores. Usamos `stringAsFactors = FALSE` para suprimir ese comportamiento:

```{r}
df <- data.frame(
  x = 1:3,
  y = c("Python", "R", "C"),
  stringsAsFactors = FALSE)
str(df)
```

Debido a que un `data.frame` es una clase S3, su tipo refleja el vector subyacente utilizado para su construcción: **la lista**. Para comprobar si un objeto es un data.frame, usamos `class()` o una  prueba explícita con `is.data.frame()`:

```{r}
typeof(df)
class(df)
is.data.frame(df)
```
Puesto que un data frame es una lista de vectores, es posible para un data frame  tener una columna que es una lista:

```{r}
df <- data.frame(x = 1:3)
df$y <- list(1:2, 1:3, 1:4)
df
```

Sin embargo, cuando una lista se da a  `data.frame()`, se trata de poner cada elemento de la lista en su propia columna, por lo que esto falla:

```{r}
data.frame(x = 1:3, y = list(1:2, 1:3, 1:4))
```

Una solución es utilizar `I()`, lo que provoca que `data.frame()` trate una lista como una unidad:

```{r}
dfl <- data.frame(x = 1:3, y = I(list(1:2, 1:3, 1:4)))
str(dfl)
dfl[2, "y"]
```

Del mismo modo, también es posible tener una columna de un data frame  que es una matriz o un array , siempre y cuando el número de filas coincide con el data frame:

```{r}
dfm <- data.frame(x = 1:3, y = I(matrix(1:9, nrow = 3)))
str(dfm)
dfm[2, "y"]
```


Utiliza las  lista y columnas de matrices con precaución: muchas funciones que trabajan con data frames, suponen que todas las columnas son vectores atómicos.



```{r}
(a_data_frame <- data.frame(
x = letters[1:5],
y = rnorm(5),
z = runif(5) > 0.5
))
```
```{r}
class(a_data_frame)
```

Debes observar que cada columna puede tener un tipo diferente al de las otras columnas, pero  todos los elementos dentro de una columna son del mismo tipo. Observese  también que la clase del objeto es `data.frame`, con un punto en lugar de un espacio.


En este ejemplo, las filas se han numerado automáticamente del uno al cinco. Si alguno de los vectores de entrada tenía nombres, entonces los nombres de fila se habrían tomado del primer vector de este tipo.

Por ejemplo si `y` tenía nombres, entonces esos serían dados al data frame:

```{r}
y <- rnorm(5)
names(y) <- month.name[1:5]
data.frame(
  x = letters[1:5],
  y = y,
  z = runif(5) > 0.5
)
```

Este comportamiento se puede sobreescribir pasando el argumento `row.names = NULL` a la función `data.frame:`

```{r}
data.frame(
  x = letters[1:5],
  y = y,
  z = runif(5) > 0.5,
  row.names = NULL
)
```

También es posible proporcionar sus propios nombres de fila pasando un vector a `row.names`. Este vector se convertirá en ``character`, si ya no es ese tipo


```{r}
data.frame(
  x = letters[1:5],
  y = y,
  z = runif(5) > 0.5,
  row.names = c("R", "Python", "Java", "C++", "Latex")
)
```

Los nombres de las fila se pueden recuperar o cambiar utilizando `rownames` (o `row.names`). Del mismo modo, que `colnames` y `dimnames` se pueden utilizar para obtener o establecer los nombres de las columnas y de la dimensión, respectivamente. De hecho, las funciones que se pueden utilizar para inspeccionar matrices también se pueden utilizar con data frames. `nrow`, `ncol` y `dim` funcionan exactamente de la misma manera que lo hacen en las matrices:

```{r}
rownames(a_data_frame)
```

```{r}
colnames(a_data_frame)
```

```{r}
dimnames(a_data_frame)
```

```{r}
nrow(a_data_frame)
```

```{r}
ncol(a_data_frame)
```

```{r}
dim(a_data_frame)
```

`length` devuelve el mismo valor que `ncol`, no el número total de elementos en el data frame. Del mismo modo, `names` devuelven el mismo valor que ``colnames`. Se recomienda evitar esas dos funciones y utilizar `ncol` y `colnames` en su lugar:

```{r}
length(a_data_frame)
names(a_data_frame)
```

Es posible crear un data frame  pasando diferentes longitudes de vectores, siempre que las longitudes permitan que las menores  sean recicladas a un número exacto de veces:

```{r}
data.frame( #longitudes 1, 2 y  4  OK
 x = 1, # reciclada  4 veces
 y = 2:3, # reciclada  dos veces
 z = 4:7 # no reciclado
)
```
Si las longitudes no son compatibles, se producirá un error. 

Otra consideración a la hora de crear data frames es que, por defecto, los nombres de columna se comprueban como nombres de variables válidos únicos. Esta característica se puede desactivar con  `check.names = FALSE` en  la función `data.frame`.

```{r}
data.frame(
  "A column" = letters[1:5],
  "!@#$%^&*()" = rnorm(5),
  "..." = runif(5) > 0.5,
  check.names = FALSE
)
```

Hay muchas formas diferentes de indexar un data frame. Para empezar, los enteros positivos, enteros negativos, valores lógicos y caracteres  se pueden utilizar exactamente de la misma manera que con las matrices. Estos comandos seleccionan el segundo y tercer elemento de las dos primeras columnas:

```{r}
a_data_frame[2:3, -3]
```

```{r}
a_data_frame[c(FALSE, TRUE, TRUE, FALSE, FALSE), c("x", "y")]
```

Puesto que se seleccionó más de una columna, el subconjunto resultante es también un data frane. Si sólo se hubiera seleccionado una columna, el resultado habría sido simplificado para ser un vector:

```{r}
class(a_data_frame[2:3, -3])
```

```{r}
class(a_data_frame[2:3, 1])
```

Si sólo queremos seleccionar una columna, también se puede utilizar la indexación de estilo de lista (doble corchetes con un  entero positivo o  nombre o el operador de signo de dólar con un nombre). Estos comandos seleccionan el segundo y tercer elemento de la primera columna:


```{r}
a_data_frame$x[2:3]
a_data_frame[[1]][2:3]
a_data_frame[["x"]][2:3]
```


```{r}
df1 <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])
df1[df1$x == 2, ]

```

```{r}
df1[c(1,3),]

```


```{r}
# Hay dos maneras de seleccionar columnas desde un data frame  como una lista
df1[c("x", "z")] 
```
```{r}
# Utilizando la manera seleccionar columnas desde data frame como una matriz
df1[, c("x", "z")]
```

```{r}
# Diferencias de seleccionar una unica columna
str(df1["x"])
str(df1[, "x"])
```

Los anteriores códigos muestran que esta técnica es utilizada para la extracción de filas de un data frame 

```
mtcars[mtcars$gear == 5, ]

mtcars[mtcars$gear == 5 & mtcars$cyl == 4, ]
```
`subset()` es una función  especializada para construir subconjuntos de data frames, como se ve en el siguiente ejemplo, que hace lo mismo que el código anterior

```{r}
subset(mtcars, gear == 5)
```


```{r}
subset(mtcars, gear == 5 & cyl == 4)
```




Siqueremos conseguir un subconjunto de un data frame colocando condiciones en las columnas, la función `subset()` proporciona una alternativa correcta. `subset()` toma hasta tres argumentos: un data frame, un vector lógico de condiciones para las filas y un vector de nombres de columna a guardar. La función `subset()` utiliza técnicas de evaluación especiales: en lugar de escribir `a_data_frame $y` para acceder a la columna `y`  de `a_data_frame`, sólo se escribe `y`. Del mismo modo, al seleccionar las columnas, no es necesario incluir los nombres de las columnas entre comillas, solo se escriben los nombres directamente.


```{r}
a_data_frame[a_data_frame$y > 0 | a_data_frame$z, "x"]
```

```{r}
subset(a_data_frame, y > 0 | z, x)
```
```{r}

numvec <- c(2,5,8,9,0,6,7,8,4,5,7,11)
charvec <- c("C","C++","c#","Erlang","F#",
        "Haskell","Java","Javascript","Python","Perl",
        "R","Scala")
genero <- c("M","M","F","M","M","M","F","F","F","M","M","F")
estados <- c("CO","KS","CA","IA","MO","FL","CA","CO","FL","CA","WY","AZ")
df <-  data.frame(var1=c(numvec), var2=c(charvec),
          genero=c(genero), estados=c(estados))

subset(df, var1 < 5)
```

```{r}
subset(df, var1==5, select=c(var2, estados))

```

```{r}
subset(df, var2 != "Java" & genero == "F" & var1 > 5)
```

Al igual que las matrices, los data frame se pueden transponer mediante la función `t`, pero en el proceso todas las columnas (que se convierten en filas) se convierten en el mismo tipo y todo se convierte en una matriz:

```{r}
t(a_data_frame)
```

Los data frames  también se pueden combinar utilizando `cbind()` y `rbind`. `rbind` reordena las columnas para que coincidan. `cbind` no comprueba los nombres de columnas  duplicados.


```{r}
# Misma columnas que a_data_frame, pero en otro orden

a_data_frame1 <- data.frame( 
  z = rlnorm(5),
  y = sample(5), 
  x = letters[3:7]
)
rbind(a_data_frame, a_data_frame1)
```

```{r}
cbind(a_data_frame, a_data_frame1)
```

Se puede utilizar `plyr::rbind.fill()` para combinar data frames que no tienen las mismas columnas. Para conocer más acerca del paquete **plyr** podemos revisar el artículo de  Sean C. Anderson [plyr: Split-Apply-Combine for Mortals](http://seananderson.ca/2013/12/01/plyr.html).

Es un error común  tratar de crear un data frame  con `cbind()`. Esto no funciona porque `cbind()` creará una matriz a menos que uno de los argumentos ya sea un data frame. En su lugar debemos utilizar `data.frame()` directamente:

```{r}
mala <- data.frame(cbind(a = 1:2, b = c("a", "b")))
str(mala)
good <- data.frame(a = 1:2, b = c("a", "b"),
  stringsAsFactors = FALSE)
str(good)
```


Cuando dos data frames  comparten columnas, pueden combinarse utilizando la función `merge()`. `merge()` proporciona una variedad de opciones para realizar combinaciones al estilo de base de datos. 

Para unir dos datos frames, debemos especificar qué columnas contienen los valores de clave para coincidir. De forma predeterminada, la función `merge()` utiliza todas las columnas comunes de los data frames , pero comúnmente sólo se utiliza una única columna de ID compartida. En los ejemplos siguientes, especificamos que la columna `x` contiene nuestros ID usando el argumento `by`:

```{r}
merge(a_data_frame, a_data_frame1, by = "x")
```

```{r}
merge(a_data_frame, a_data_frame1, by = "x", all = TRUE)
```

Cuando un data frame  tiene todos los valores numéricos, las funciones `colSums` y `colMeans` se pueden utilizar para calcular las sumas y la media  de cada columna, respectivamente. Similarmente, `rowSums` y `rowMeans` calculan las sumas y la media de cada fila:


```{r}
colSums(a_data_frame[, 2:3])
```

```{r}
colMeans(a_data_frame[, 2:3])
```

un ejemplo de la función `merge()` utilizando [Rankings de Lenguajes de Programación 2015](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html)

```{r}
help(merge)

lenguajesP <- c("Java","C", "C++", "Python", "JS", "Ruby", "R")
puestoR <- c(1, 2,3, 5, 7, 12, 19)
dataF <- data.frame(lenguajesP,puestoR,stringsAsFactors=FALSE)

lenguajesQ <- c("C#","Perl", "Assembly", "Switf", "Matlab", "SQL", "Cobol")
#lenguajesP <- c("Java","C", "C++", "Python", "JS", "Ruby", "R")
puestoR1<- c(4, 9, 10, 12, 19, 20, 22)
dataG <- data.frame(lenguajesP,puestoR1,stringsAsFactors=FALSE)

merge(dataF, dataG)
```

Podemos utilizar las funciones `lapply()` y `sapply()` con data frames


```{r}
dataI <-lapply(dataF, sort)
dataI
```

```{r}
as.data.frame(dataI)
```

```{r}
#Ejemplo con sapply

pnums <- read.table("loteria.txt", header=TRUE)
names(pnums)

meses <- pnums[2:13]
sapply(meses, median, na.rm = TRUE)
mediana <-sapply(meses, median, na.rm=TRUE)
plot(mediana, type="b", xlab="Numero de Meses")
```


```{r}
# Leamos un archivo de datos

examen <- read.table("Examen.txt",header=TRUE )
head(examen)

```
```{r}
class(examen)
```

```{r}
# Realicemos operaciones con este data frame
examen[2:5,]
```

```{r}
examen[2:5,2,drop=FALSE]
```

```{r}
#Realizamos filtrado

examen[examen$quiz.prom >= 2.8,]
```

```{r}
subset(examen, examen$quiz.prom < 1.5)
```

```{r}
# Creemos una columnas a partir de otras

ex1<-examen$tarea.prom -examen$quiz.prom
ex <- cbind(examen,ex1 )
head(ex)
```

```{r}
class(ex)
```
Aplicamos la función `àpply()`

```{r}
apply(examen, 1, max)
```

